### OSI七层网络模型
设定了网络通信协议的规范，厂商必须要遵循这个模型来设计自己的网络通信协议。
* 物理层：传递电信号(0和1)
* 数据链路层：把一组电信号成为帧，每个帧包含两部分，分别是标头和数据体。
```text
标头里包含了数据帧从哪里发出，要发到哪个地址(MAC地址)，以及节点的数据类型。数据体是真正要发送的数据。
MAC地址是网卡生产商写在网卡中的12位十六进制的序列号，这个序列号是全球唯一的编号，序列号前6个十六进制是厂商编号，后6个十六进制是网卡的流水号。
局域网中的一台电脑要向外发送数据时，会向自己所在的局域网中所有的电脑发送请求。局域网内的其他电脑收到请求后，会对比标头里的MAC地址，如果和自己相同，就接收，并做进一步处理。否则丢弃。这是一个协议，叫以太网协议。
广播是向局域网内部广播，不是整个互联网。也就是说数据链路层的工作只在某个局域网内。
```
* 网络层
```text
数据链路层负责局域网内部的通信，如果要访问其他局域网，这就是网络层负责的。
网络层也有自己的协议，叫IP协议。
假设现在有两个局域网，局域网1和局域网2，通过两个路由器联通。
此时局域网1的某台电脑往局域网之外发送请求，首先通过广播向自己所在的局域网中所有的有网卡的机器(包括路由器)发送请求，局域网内部的电脑不会处理，路由器收到请求后，发现目标MAC地址和自己的不一样，就会转发给其他局域网的路由器，然后局域网2会判断这个地址是不是内部的机器，如果属于就不会再寻找其他局域网了。
```
```text
这里有个问题，路由器怎么知道这个MAC地址是不是局域网内部的机器呢？
就在于当一个局域网建立的时候，所有电脑都会向局域网内的所有机器广播自己的IP和MAC地址，这样路由器就有了局域网内的所有电脑的IP和MAC地址列表。
```
```text
如何判断哪些机器在一个局域网(子网)里呢？
IP地址分两段，第一段表示局域网，第二段表示主机。如果两台电脑的IP地址局域网部分相同，那就说明在同一个局域网。
而子网掩码就是用来判断IP地址的局域网。
比如一个IPV4地址，192.168.0.1，前三段192.168.0表示局域网，最后一段1表示主机。 -- 不一定是IP地址前三段，此处为举例，实际会根据子网掩码做区分，来确定应该取几段。
在这个地址里，子网掩码用前面N位二进制的1来代表局域网标识，剩下的表示主机。
比如常见的子网掩码255.255.255.0，对应的就是1111 1111.1111 1111.1111 1111.0000 0000。
判断是否同一个子网，用电脑的IP地址和子网掩码做&运算(与运算)，然后看前三段是否一致。一致的话就在一个局域网里。
```
* 传输层
```text
引入端口概念。
```
* 会话层
* 表示层
* 应用层


### TCP/IP四层网络协议
```text
当今互联网正在使用的通用的网络协议。
OSI7层网络模型仅仅是一个标准，而基于7层网络协议实现的4层网络协议（又称TCP/IP协议）才是现在真正使用的互联网协议。
```
* 数据链路层(也叫网络接口层，包含了7层模型中的数据链路层和物理层)
* 网络层
* 传输层
* 应用层(包含了7层模型中的会话层、表示层、应用层)
TCP/IP协议的流程：

| 数据包格式                      | 客户端               |       | 服务端                | 数据包格式                      |
|----------------------------|-------------------|-------|--------------------|----------------------------|
| GET/HTTP/1.1               | 根据HTTP协议组装数据包     | 应用层   | HTTP报文解析           | GET/HTTP/1.1               |
| TCP头 GET/HTTP/1.1          | 增加TCP头部，包括端口号序列号等 | 传输层   | TCP报文解析            | TCP头 GET/HTTP/1.1          |
| IP头 TCP头 GET/HTTP/1.1      | 增加IP头部，包括源IP地址等   | 网络层   | IP报文解析，传送数据包，确定路由  | IP头 TCP头 GET/HTTP/1.1      |
| 以太网头 IP头 TCP头 GET/HTTP/1.1 | 增加以太网头部，包括MAC地址等  | 网络接口层 | 根据MAC地址，判断是不是传给自己的 | 以太网头 IP头 TCP头 GET/HTTP/1.1 |

分层的好处：
```text
各层独立：各层之间使用标准化的接口，各层不需要知道上下层是如何工作的。
灵活性强：比如路由器不需要应用层和传输层，分层以后路由器就可以只用加载更少的几个协议层。
易于测试和维护：提高了可测试性，可以独立地测试特定层，某一层有了更好的实现可以整体替换掉。
能促进标准化：每一层职责清楚，方便进行标准化。
```

### 传输层协议
分为TCP协议和UDP协议。

|        | TCP(Transmission Control Protocol,传输控制协议) | UDP(User Datagram Protocol,用户数据报协议) |
|--------|-------------------------------------------|-------------------------------------|
| 连接性    | 面向连接                                      | 无连接                                 |
| 可靠性    | 可靠传输，不丢包                                  | 不可靠传输，尽最大努力交付                       |
| 首部占用空间 | 大                                         | 小                                   |
| 传输效率   | 慢                                         | 快                                   |
| 资源消耗   | 大                                         | 小                                   |
| 应用场景   | 浏览器，文件传输，发送邮件                             | 音视频通话，直播                            |
| 应用层协议  | HTTP，HTTPS,FTP,SMTP                       | DNS                                 |

#### TCP协议
面向字节流，传输层只负责把应用层的数据字节流化，解释字节流是应用层的事情。我只负责传输，不管传输的是什么。

* 数据结构
  1. 数据头
    * 16位源端口号：和IP首部的源IP地址组成发送端的IP:PORT
    * 16位目的端口号：和IP首部的目的IP地址组成接收端的IP:PORT
    * 32位序号：无符号数。对每次发送数据的字节进行计数。
    * 32位确认序号：接收方下次要接收的字节位置。
    * 4位首部长度：TCP 一次请求的数据头的大小。
    * 保留6位
    * UCR：紧急指针，告诉接收端是紧急的，需要优先处理。
    * ACK：确认序号有效，接收方告诉发送方，这个序号之前的数据都收到了，下次需要的数据从这个序号开始。
    * PSH：接收方应尽快将数据从TCP放到应用层里。
    * RST：重建连接，也就是说之前的连接异常，需要重新连接。
    * SYN：同步序号，用来发起一个连接，用来做TCP连接建立的。
    * FIN：发送端完成发送任务。用来做TCP连接关闭的。
    * 16位窗口大小
    * 16位检验和
    * 16位紧急指针
    * 选项
    * 数据
  2. 数据体

* 三次握手
* 四次挥手
#### UDP协议