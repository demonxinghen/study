动态规划问题的一般形式就是求最值, 其实是运筹学的一种最优化算法.

在计算机里比如求最长递增子序列, 最小编辑距离等等.

求解动态规划的核心问题是穷举.

动态规划穷举的特点:

1. 存在重叠子问题.
2. 具备最优子结构.
3. 列出正确的状态转移方程(最难).

以斐波那契为例:
```java
public class Fib{
    int fib(int N){
        if (N == 1 || N == 2) return 1;
        return fib(N - 1) + fib(N - 2);
    }
}
```
这是最基本的递归解法, 低效在中间存在大量重复的fib(N)计算. 这也就是重叠子问题.

所以我们可以通过使用Map或者数组来存放中间值, 已经计算过的直接取值即可, 这种解法和迭代的动态规划思想已经差不多, 只不过这种方法叫做「自顶向下」, 动态规划叫做「自底向上」.

什么叫自顶向下, 比如我们计算fib(N), 向下拆解为fib(N-1)和fib(N-2),一直到fib(1)和fib(2),然后逐层返回答案.

那么自底向上就是从fib(1)和fib(2)开始向上推,一直算到fib(N).

所以我们可以建立一个长度为N+1的数组array,array[0]空着, array[1] = fib(1), array[2] = fib(2), 开始计算array[3], 一直到array[N].

fib(N)=fib(N - 1) + fib(N - 2),这个就是状态转移方程. 也是最难写的, 一般代表着暴力解法.

斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值.


