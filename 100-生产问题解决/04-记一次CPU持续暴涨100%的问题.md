### 背景:
```text
mybatis-plus, 3.5.4.1
自定义插件 MyDataPermissionInterceptor, 实现默认排序
自定义插件 DataIsolationHandler, 实现租户隔离(项目中有许多特殊情况,会跨租户隔离,所以没有使用mybatis-plus提供的TenantLineInnerInterceptor)
DataIsolationHandler中根据where.toString()判断是否需要添加租户隔离条件, 如果已经包含, 则不添加, 否则根据table反射该类, 获取是否有租户隔离字段或者租户隔离注解, 如果有, 则添加租户隔离条件
```

### 第一次发现问题, 没有考虑复杂sql, 只考虑了简单的sql, 在有join的情况下, 会出现表名不明确, 导致ambiguous column
```java
public class DataIsolationHandler implements MultiDataPermissionHandler {
    @Override
    public Expression getSqlSegment(Table table, Expression where, String mappedStatementId) {
        // ...其他逻辑
        if (table.getASTNode() != null && table.getASTNode().jjtGetParent() != null && "JoinerExpression".equalsIgnoreCase(table.getASTNode().jjtGetParent().toString())) {
            Node node = table.getASTNode().jjtGetParent();
            if (node instanceof SimpleNode) {
                SimpleNode simpleNode = (SimpleNode) node;
                if (simpleNode.jjtGetValue() != null) {
                    String joinTable = simpleNode.jjtGetValue().toString().toLowerCase();
                    if (joinTable.contains(" join ")) {
                        return null;
                    }
                }
            }
        }
        // ...其他逻辑
    }
}
```

### 第二次优化, 注释上面的代码, 改为别名方式
```java
public class DataIsolationHandler implements MultiDataPermissionHandler {
    @Override
    public Expression getSqlSegment(Table table, Expression where, String mappedStatementId) {
        // ...其他逻辑
        EqualsTo customerExpression = new EqualsTo();
        if (table.getAlias() != null) {
            customerExpression.setLeftExpression(new Column(table.getAlias().getName() + ".customer_id"));
        } else {
            customerExpression.setLeftExpression(new Column("customer_id"));
        }
        // ...其他逻辑
    }
}
```

### 开始出现问题, 频繁报错, 且cpu一直拉满, 掉不下来
```text
"pool-297150-thread-1" #299049 prio=5 os_prio=0 tid=0x000055da6dcae800 nid=0x2e8d92 runnable [0x00007fbd77880000] java.lang.Thread.State: RUNNABLE 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_scan_token(CCJSqlParser.java:38720) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_SimpleJdbcParameter_2996_5_248(CCJSqlParser.java:27096) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3_227(CCJSqlParser.java:35582) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_PrimaryExpression_3990_5_235(CCJSqlParser.java:35644) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_BitwiseXor_3931_5_245(CCJSqlParser.java:35938) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_MultiplicativeExpression_3901_5_240(CCJSqlParser.java:36011) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_AdditiveExpression_3877_5_482(CCJSqlParser.java:36060) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_BitwiseAndOr_3845_5_237(CCJSqlParser.java:36119) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_ConcatExpression_3822_5_191(CCJSqlParser.java:36143) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_SimpleExpression_3798_5_153(CCJSqlParser.java:36229) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3_212(CCJSqlParser.java:36475) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_ComparisonItem_3750_3_218(CCJSqlParser.java:36523) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_RegularCondition_3346_5_216(CCJSqlParser.java:37924) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_Condition_3314_9_392(CCJSqlParser.java:38046) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_Condition_3312_5_190(CCJSqlParser.java:38073) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_AndExpression_3275_9_407(CCJSqlParser.java:38184) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_AndExpression_3274_5_210(CCJSqlParser.java:38192) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_OrExpression_3252_5_209(CCJSqlParser.java:38218) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_XorExpression_3233_5_355(CCJSqlParser.java:38249) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_Expression_3223_5_149(CCJSqlParser.java:38274) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3_209(CCJSqlParser.java:36954) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3_207(CCJSqlParser.java:36983) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3R_ComplexExpressionList_3635_5_152(CCJSqlParser.java:37067) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_3_196(CCJSqlParser.java:37471) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_rescan_token(CCJSqlParser.java:39089) 
at net.sf.jsqlparser.parser.CCJSqlParser.generateParseException(CCJSqlParser.java:38860) 
at net.sf.jsqlparser.parser.CCJSqlParser.jj_consume_token(CCJSqlParser.java:38696) 
at net.sf.jsqlparser.parser.CCJSqlParser.InExpression(CCJSqlParser.java:12846) 
at net.sf.jsqlparser.parser.CCJSqlParser.SQLCondition(CCJSqlParser.java:12757) 
at net.sf.jsqlparser.parser.CCJSqlParser.Condition(CCJSqlParser.java:12491) 
at net.sf.jsqlparser.parser.CCJSqlParser.AndExpression(CCJSqlParser.java:12414) 
at net.sf.jsqlparser.parser.CCJSqlParser.OrExpression(CCJSqlParser.java:12325) 
at net.sf.jsqlparser.parser.CCJSqlParser.XorExpression(CCJSqlParser.java:12307) 
at net.sf.jsqlparser.parser.CCJSqlParser.Expression(CCJSqlParser.java:12278) 
at net.sf.jsqlparser.parser.CCJSqlParser.WhereClause(CCJSqlParser.java:11560) 
at net.sf.jsqlparser.parser.CCJSqlParser.PlainSelect(CCJSqlParser.java:7863) 
at net.sf.jsqlparser.parser.CCJSqlParser.SetOperationList(CCJSqlParser.java:8107) 
at net.sf.jsqlparser.parser.CCJSqlParser.SelectBody(CCJSqlParser.java:7718) 
at net.sf.jsqlparser.parser.CCJSqlParser.Select(CCJSqlParser.java:7713) 
at net.sf.jsqlparser.parser.CCJSqlParser.SingleStatement(CCJSqlParser.java:377) 
at net.sf.jsqlparser.parser.CCJSqlParser.Statement(CCJSqlParser.java:285) 
at net.sf.jsqlparser.parser.CCJSqlParserUtil$1.call(CCJSqlParserUtil.java:253) 
at net.sf.jsqlparser.parser.CCJSqlParserUtil$1.call(CCJSqlParserUtil.java:250) 
at java.util.concurrent.FutureTask.run(FutureTask.java:266) 
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 
at java.lang.Thread.run(Thread.java:750)
```
初步怀疑是大sql导致的where.toString().contains("customer_id")有问题,因为在JSON.toJSONString(where)尝试查看where条件的时候,显示递归深度过多,出错, 且每次执行sql都会反射获取字段

原代码
```java
public class DataIsolationHandler implements MultiDataPermissionHandler {
    @Override
    public Expression getSqlSegment(Table table, Expression where, String mappedStatementId) {
        if (where != null && where.toString().contains("customer_id")) {
            return null;
        }
        // ...其他逻辑
        String className = mappedStatementId.substring(0, mappedStatementId.lastIndexOf("."));
        Class<?> clazz = Class.forName(className);
        String entityClassName = ((ParameterizedTypeImpl) clazz.getGenericInterfaces()[0]).getActualTypeArguments()[0].getTypeName();
        Class<?> entity = Class.forName(entityClassName);
        if (entity.isAnnotationPresent(NonIsolation.class)) {
            return null;
        }
        try {
            entity.getSuperclass().getDeclaredField("customerId");
        } catch (NoSuchFieldException e) {
            entity.getDeclaredField("customerId");
        }
        EqualsTo customerExpression = new EqualsTo();
        if (table.getAlias() != null) {
            customerExpression.setLeftExpression(new Column(table.getAlias().getName() + ".customer_id"));
        } else {
            customerExpression.setLeftExpression(new Column("customer_id"));
        }
        customerExpression.setRightExpression(new StringValue(user.getCustomerId()));
        return customerExpression;
        // ...其他逻辑
    }
}
```

### 第一版优化, 使用缓存减少字段的反射
```java
public class DataIsolationHandler implements MultiDataPermissionHandler {

    private static final Map<Class<?>, Boolean> CACHE = new ConcurrentHashMap<>();

    @Override
    public Expression getSqlSegment(Table table, Expression where, String mappedStatementId) {
        if (where != null && containsCustomerIdColumn(where)) {
            return null;
        }
        // ...其他逻辑
        TableInfo tableInfo = TableInfoHelper.getTableInfo(table.getName());
        Class<?> entity = tableInfo.getEntityType();
        if (!hasCustomerId(entity)) {
            return null;
        }
        EqualsTo customerExpression = new EqualsTo();
        if (table.getAlias() != null) {
            customerExpression.setLeftExpression(new Column(table.getAlias().getName() + ".customer_id"));
        } else {
            customerExpression.setLeftExpression(new Column("customer_id"));
        }
        customerExpression.setRightExpression(new StringValue(user.getCustomerId()));
        return customerExpression;
        // ...其他逻辑
    }

    private boolean hasCustomerId(Class<?> clazz) {
        return CACHE.computeIfAbsent(clazz, c -> {
            Class<?> current = c;
            while (current != null && current != Object.class) {
                for (Field field : current.getDeclaredFields()) {
                    if ("customerId".equals(field.getName())) {
                        return true;
                    }
                }
                current = current.getSuperclass();
            }
            return false;
        });
    }

    private static class CustomerIdVisitor extends ExpressionVisitorAdapter {
        // 定义该字段方便快速判断, 避免冗余遍历
        private boolean hasCustomerId = false;

        @Override
        public void visit(Column column) {
            if (!hasCustomerId && "customer_id".equalsIgnoreCase(column.getColumnName())) {
                hasCustomerId = true;
            }
        }

        public void visitBinaryExpression(BinaryExpression expr) {
            if (hasCustomerId) return;
            expr.getLeftExpression().accept(this);
            if (hasCustomerId) return;
            expr.getRightExpression().accept(this);
        }

        @Override
        public void visit(AndExpression expr) {
            visitBinaryExpression(expr);
        }

        @Override
        public void visit(OrExpression expr) {
            visitBinaryExpression(expr);
        }

        @Override
        public void visit(EqualsTo expr) {
            visitBinaryExpression(expr);
        }

        @Override
        public void visit(NotEqualsTo expr) {
            visitBinaryExpression(expr);
        }

        @Override
        public void visit(GreaterThan expr) {
            visitBinaryExpression(expr);
        }

        @Override
        public void visit(GreaterThanEquals expr) {
            visitBinaryExpression(expr);
        }

        @Override
        public void visit(MinorThan expr) {
            visitBinaryExpression(expr);
        }

        @Override
        public void visit(MinorThanEquals expr) {
            visitBinaryExpression(expr);
        }

        @Override
        public void visit(LikeExpression expr) {
            visitBinaryExpression(expr);
        }

        @Override
        public void visit(Parenthesis expr) {
            if (hasCustomerId) return;
            expr.getExpression().accept(this);
        }

        @Override
        public void visit(InExpression expr) {
            if (hasCustomerId) return;
            expr.getLeftExpression().accept(this);
        }

        @Override
        public void visit(Between expr) {
            if (hasCustomerId) return;
            expr.getLeftExpression().accept(this);
        }

        @Override
        public void visit(IsNullExpression expr) {
            if (hasCustomerId) return;
            expr.getLeftExpression().accept(this);
        }

        @Override
        public void visit(NotExpression expr) {
            if (hasCustomerId) return;
            expr.getExpression().accept(this);
        }

        public boolean hasCustomerId() {
            return hasCustomerId;
        }
    }
}
```
上线后, 问题并没有解决, 且这次指向了MyDataPermissionInterceptor, 尝试注释该MyDataPermissionInterceptor, 直接使用系统默认的DataPermissionInterceptor, 问题没有解决

### 觉得是大SQL问题, 导致CCJSqlParser解析耗时过长, 导致CPU持续暴涨100%
```java
public class MyDataPermissionInterceptor extends DataPermissionInterceptor {
    @Override
    protected void processSelect(Select select, int index, String sql, Object obj) {
        if (sql != null && sql.length() > 3000) {
            return;
        }
        SelectBody selectBody = select.getSelectBody();
        if (selectBody instanceof PlainSelect) {
            if (CollectionUtils.isEmpty(((PlainSelect) selectBody).getOrderByElements())) {
                ((PlainSelect) selectBody).setOrderByElements(getDefaultOrder(selectBody));
            }
            this.setWhere((PlainSelect) selectBody, (String) obj);
        } else if (selectBody instanceof SetOperationList) {
            if (CollectionUtils.isEmpty(((SetOperationList) selectBody).getOrderByElements())) {
                ((SetOperationList) selectBody).setOrderByElements(getDefaultOrder(selectBody));
            }
            SetOperationList setOperationList = (SetOperationList) selectBody;
            List<SelectBody> selectBodyList = setOperationList.getSelects();
            selectBodyList.forEach(s -> this.setWhere((PlainSelect) s, (String) obj));
        }
    }
}
```
问题依然没有解决, 直接return会导致this.setWhere((PlainSelect) selectBody, (String) obj);被跳过, 导致数据隔离失效. 单独再调用该方法也没有意义, 因为本来就是默认DataPermissionInterceptor的逻辑,前面已经证实了没用

### 到这里, 基本判断问题不出在MyDataPermissionInterceptor和DataPermissionInterceptor, 问题出在CCJSqlParser解析大SQL耗时过长, 导致CPU持续暴涨100%
现在就需要查找大SQL
```java
public class MyDataPermissionInterceptor extends DataPermissionInterceptor {
    @Override
    public void beforeQuery(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
        if (InterceptorIgnoreHelper.willIgnoreDataPermission(ms.getId())) {
            return;
        }
        PluginUtils.MPBoundSql mpBs = PluginUtils.mpBoundSql(boundSql);
        String sql = mpBs.sql();
        log.info("beforeQuery, sql长度{}", sql.length());
        log.info("beforeQuery, sql: {}", sql);
        mpBs.sql(parserSingle(sql, ms.getId()));
        log.info("sql parsing complete");
    }
}
```
上线后发现有单sql的length达到800万,甚至过千万.