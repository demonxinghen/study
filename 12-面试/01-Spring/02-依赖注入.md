1. constructor-args(无法解决循环依赖)
```java
public class ExampleBean{
    private final MovieFinder movieFinder;
    
    public ExampleBean(MovieFinder movieFinder){
        this.movieFinder = movieFinder;
    }
}
```
2. setter
```java
public class ExampleBean{
    private MovieFinder movieFinder;
    
    public void setMovieFinder(MovieFinder movieFinder){
        this.movieFinder = movieFinder;
    }
}
```
基于构造参数和基于setter可以混合使用，因此使用构造参数作为强依赖项，使用setter作为一个可选依赖项是一个很好的经验法则。

setter方法上加上@Autowired会使其变成必需依赖项。

A依赖B，spring会先把B全部初始化。 -- **待验证**

xml配置中ref和idref的区别

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="target" class="com.example.spring.TargetBean">

    </bean>

    <bean id="testXmlBean" class="com.example.spring.TestXmlBean" destroy-method="destroy">
        <property name="targetBean">
            <!-- <idref bean="target"/>--> <!-- idref是引入bean的id,是一个字符串 -->
            <ref bean="target"/> <!-- ref是引入bean，是一个BeanDefinition -->
        </property>
<!--        &lt;!&ndash; <property name="targetBean" value="target"></property>&ndash;&gt; 类似于上面的idref,都是引入一个字符串，区别是idref可以更快的校验bean是否存在，如果使用value要在实际实例化的时候才发现，如果是原型bean，可能运行很久以后才发现-->
    </bean>
    
</beans>
```

自动装配：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="target" class="com.example.spring.TargetBean" autowire="constructor"></bean>
</beans>
```
xml方式中autowire有五个值：
* no: 默认值,不装配
* default: no
* byName: 属性名,setter方法
* byType: 
* constructor: 类似于type,但适用于构造参数

depends-on的作用是告诉spring在初始化之前先初始化depends-on的bean，本身并不能引入依赖。